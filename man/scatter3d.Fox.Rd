% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/scatter3d.Fox.R
\name{scatter3d.Fox}
\alias{scatter3d.Fox}
\title{Function that draws an scatterplot with three dimensions with confidence ellipsoid. From John Fox. This is an older version. Please use ellipsoid3d in package car}
\usage{
scatter3d.Fox(x, y, z, xlab = deparse(substitute(x)),
  ylab = deparse(substitute(y)), zlab = deparse(substitute(z)),
  revolutions = 0, bg.col = c("white", "black"), axis.col = if (bg.col ==
  "white") "black" else "white", surface.col = c("blue", "green", "orange",
  "magenta", "cyan", "red", "yellow", "gray"), neg.res.col = "red",
  pos.res.col = "green", point.col = "yellow", text.col = axis.col,
  grid.col = if (bg.col == "white") "black" else "gray", fogtype = c("exp2",
  "linear", "exp", "none"), residuals = (length(fit) == 1), surface = TRUE,
  grid = TRUE, grid.lines = 26, df.smooth = NULL, df.additive = NULL,
  sphere.size = 1, threshold = 0.01, speed = 1, fov = 60,
  fit = "linear", groups = NULL, parallel = TRUE, ellipsoid = FALSE,
  level = 0.5, model.summary = FALSE)
}
\arguments{
\item{x,y,x}{vectors to be plotted}

\item{xlab,}{ylab, zlab axis labels.}

\item{revolutions}{number of full revolutions of the display.}

\item{bg.col}{background colour; one of "white", "black".}

\item{axis.col}{colours for axes; if axis.scales is FALSE, then the second colour is used for all three axes.}

\item{surface.col}{vector of colours for regression planes, used in the order specified by fit; for multi-group plots, the colours are used for the regression surfaces and points in the several groups.}

\item{neg.res.col,}{pos.res.col colours for lines representing negative and positive residuals.}

\item{point.col}{colour of points.}

\item{text.col}{colour of axis labels.}

\item{grid.col}{colour of grid lines on the regression surface(s).}

\item{fogtype}{type of fog effect; one of "exp2", "linear", "exp", "none".}

\item{residuals}{plot residuals if TRUE; if residuals="squares", then the squared residuals are shown as squares (using code adapted from Richard Heiberger). Residuals are available only when there is one surface plotted.}

\item{surface}{plot surface(s) (TRUE or FALSE).}

\item{grid}{plot grid lines on the regression surface(s) (TRUE or FALSE).}

\item{grid.lines}{number of lines (default, 26) forming the grid, in each of the x and z directions.}

\item{df.smooth}{degrees of freedom for the two-dimensional smooth regression surface; if NULL (the default), the gam function will select the degrees of freedom for a smoothing spline by generalized cross-validation; if a positive number, a fixed regression spline will be fit with the specified degrees of freedom.}

\item{df.additive}{degrees of freedom for each explanatory variable in an additive regression; if NULL (the default), the gam function will select degrees of freedom for the smoothing splines by generalized cross-validation; if a positive number or a vector of two positive numbers, fixed regression splines will be fit with the specified degrees of freedom for each term.}

\item{sphere.size}{general size of spheres representing points; the actual size is dependent on the number of observations.}

\item{threshold}{if the actual size of the spheres is less than the threshold, points are plotted instead.}

\item{speed}{relative speed of revolution of the plot.}

\item{fov}{field of view (in degrees); controls degree of perspective.}

\item{fit}{one or more of "linear", "quadratic", "smooth", "additive"; to display fitted surface(s); partial matching is supported -- e.g., c("lin", "quad").}

\item{groups}{if NULL (the default), no groups are defined; if a factor, a different surface or set of surfaces is plotted for each level of the factor; in this event, the colours in surface.col are used successively for the points, surfaces, and residuals corresponding to each level of the factor.}

\item{parallel}{when plotting surfaces by groups, should the surfaces be constrained to be parallel? A logical value, with default TRUE.}

\item{ellipsoid}{TRUE if a confidence ellipsoid is to be draw. Default to FALSE}

\item{level}{expected proportion of bivariate-normal observations included in the concentration ellipsoid(s); default is 0.5.}

\item{model.summary}{print summary or summaries of the model(s) fit (TRUE or FALSE). scatter3d rescales the three variables internally to fit in the unit cube; this rescaling will affect regression coefficients.}

\item{axis.scales}{if TRUE, label the values of the ends of the axes. Note: For identify3d to work properly, the value of this argument must be the same as in scatter3d.}

\item{surface.alpha}{transparency of regression surfaces, from 0.0 (fully transparent) to 1.0 (opaque); default is 0.5.}

\item{square.col}{colour to use to plot squared residuals.}

\item{fill}{fill the plotted surface(s) with colour (TRUE or FALSE).}

\item{radius}{relative radii of the spheres representing the points. This is normally a vector of the same length as the variables giving the coordinates of the points, and for the formula method, that must be the case or the argument may be omitted, in which case spheres are the same size; for the default method, the default for the argument, 1, produces spheres all of the same size. The radii are scaled so that their median is 1.}

\item{ellipsoid}{plot concentration ellipsoid(s) (TRUE or FALSE).}
}
\description{
The scatter3d function uses the rgl package to draw 3D scatterplots with various regression surfaces. The function identify3d allows you to label points interactively with the mouse: Press the right mouse button (on a two-button mouse) or the centre button (on a three-button mouse), drag a rectangle around the points to be identified, and release the button. Repeat this procedure for each point or set of “nearby” points to be identified. To exit from point-identification mode, click the right (or centre) button in an empty region of the plot.
}
\examples{
x=rnorm(50); y=3*x+4+rnorm(50,0,.1); z=x+y+rnorm(50,0,.1)
scatter3d.Fox(x,y,x)
}

